---
sidebar_position: 1
title: Introduction to Heap Data Structure
---

### what is `heap` data structure ?

> it is a special tree based data structure where tree is `complete binary tree`.

### why we need the `heap` data structure ?

> so the simple answer is we need a `high priority element` in `O(1)` time. now by high priority element can either be max element or min element so on this basis we have 2 kind of heaps

- **Min Heap** : where from all the elements in the tree we can get the min element(high priority = min_element)
- **Max Heap** : where from all the elements in the tree we can get the max element(high priority = max_element)

### what is complete binary tree ?

> A complete binary tree is just like a full binary tree, but with two major differences:

- Every level must be completely filled
- The last leaf element might not have a right sibling i.e. a complete binary tree doesnâ€™t have to be a full binary tree

> in a easy term we can say that we can convert the complete binary tree into array form, where every element in an array is filled.

### Operations/APIS in a heap

- #### `push(int element)`: push the element in the heap
- #### `peek()`: return the top/peek/root element in heap
- #### `poll()`: remove the top/peek/root element in heap
- #### `isEmpty()`: return true/false that is our heap is empty or not
- #### `heapify()`: it is not a operation, but a step which is used to satisfy the properties of the heap tree used by `push()` and `remove()` operations

### Implementation of a min heap

<Tabs>
<TabItem value="java" label="Java">

```js
import java.util.*;
public class Main {
    public static void main(String[] argv){
        Heap heap = new Heap();
        // operations performed on heap data structure
        heap.insert(4);heap.insert(1);heap.insert(3);heap.insert(9);heap.insert(7);
        System.out.println(heap.tree);
        while(!heap.isEmpty()){
            System.out.print(heap.poll()+" ");
            System.out.println(heap.tree);
        }
    }
}

class Heap{
    ArrayList<Integer> tree;// tree in the form of array
    Heap(){
        tree = new ArrayList<>();
    }
    public void insert(int element){
        tree.add(element);// add the new element to the last of the array
        int element_index = tree.size()-1;// index of the new element
        int parent_index = (element_index+1)/2 - 1;// parent index of new element
        // heapify process
        while(parent_index>=0 && tree.get(element_index) < tree.get(parent_index)){
            swap(element_index,parent_index);// swap both the values
            element_index = parent_index;
            parent_index = (element_index+1)/2 - 1;
        }
    }
    public int peek(){
        return isEmpty() ? -1: tree.get(0);
    }
    public int poll(){
        if(isEmpty())return -1;
        int peek_element = peek(), last_index = tree.size()-1;
        swap(0,last_index);// now we have to remove peek so swap and remove with last element
        tree.remove(last_index);// remove the last element
        // heapify
        int size = tree.size();
        int parent_index = 0,left_child_index = 1, right_child_index = 2;
        while(true) {
            int minimum_element_index = parent_index;
            if(left_child_index < size && tree.get(left_child_index) < tree.get(minimum_element_index)){
                minimum_element_index = left_child_index;
            }
            if (right_child_index < size && tree.get(right_child_index) < tree.get(minimum_element_index)) {
                minimum_element_index = right_child_index;
            }
            // check if we need to reiterate the process or not
            if(minimum_element_index!=parent_index){
                swap(minimum_element_index,parent_index);
                parent_index = minimum_element_index;
                left_child_index = 2 * parent_index + 1;
                right_child_index = 2 * parent_index + 2;
            }else{
                break;
            }
        }
        return peek_element;
    }
    public boolean isEmpty() {
        return this.tree.size()==0;
    }
    public void swap(int index1,int index2){
        int temp = this.tree.get(index1);
        this.tree.set(index1,this.tree.get(index2));
        this.tree.set(index2,temp);
    }
}


```

</TabItem>

<TabItem value="other" label="Other">

```
currently no other languages supported
```

</TabItem>

</Tabs>

### Time Complexity Operation wise:

> heapify takes `O(logN)` time which is used in both insert and delete operation

### where we used heap data structure ?

> so heap is a data structure which is used to implement the Abstract data Type which is priority queue.
> so Abstract Data Type(ADT) is a data type about which we not know the implementation but know about the operations
> so heap is the implementation of the Priority Queue ADT.

