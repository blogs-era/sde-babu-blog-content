---
sidebar_position: 2
title: Sum of Subarray Minimums 
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

export const Highlight = ({children, color,txt}) => (
  <span
    style={{
      backgroundColor: color,
      borderRadius: '2px',
      color: '#fff',
      padding: '0.2rem',
    }}>
    {children}
  </span>
);

Level - <Highlight color="#fece2f">Medium</Highlight>

### Statement

> Given an array of integers arr, find the sum of `min(b)`, where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo `10^9 + 7`

### Example 1
```
Input: arr = [3,1,2,4]
Output: 17
Explanation: 
Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. 
Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.
Sum is 17.

```

### You can try it at

- https://leetcode.com/problems/sum-of-subarray-minimums/

### Brute force approach

- brute force approach is to get all the `subarrays`
- and then get the minimum element for each subarray
- and add it to the sum but this will take `O(N^3)` which will give `TLE`

### Optimal Approach


:::note
before visiting this optimal approach please read about [next greater element](./next_greater_element.mdx) or next smaller element concept.where we use stack to solve these kind of problems
:::

- lets take an example to understand the optimal approach, `eg:[3,1,2,4]`
- lets take first element which is `3`, so `3` can be minimum in range `[3]`, so number of subarrays formed is `i-start_index+1 * end_index-i+1` so, `(0-0+1) * (0-0+1) = 1`
- lets take second element which is `1`, so `1` can be minimum in range `[3,1,2,4]`, so number of subarrays formed is `(1-0+1)*(3-1+1) = 3*2 = 6`
- lets take third element which is `2`, so `2` can be minimum in range `[2,4]`, so number of subarrays formed is `(2-2+1)*(3-2+1) = 2`
- lets take fourth element which is `4`, so `4` can be minimum in range `[4]` so number of subarrays formed is `(3-3+1)*(3-3+1) = 1`
- so in above for each element we got `number of subarrays formed when that element is considered to be minimum`
- so `number_of_subbary[i]` = `left[i]*right[i]` where `left[i]` is `a[i]-start_index+1` and `right[i]` is `end_index-arr[i]+1`
- now we need to calculate the sum so simply iterate through arr and add `number_of_subbary[i]*arr[i]` to the sum, so we get `3*1 + 1*6 + 2*2 + 4*1` = `17`
- now the main challenge is to get range for each element in array for that we use stack to calculate next smaller element from left and right side
- so lets understand why we use `next smaller element` so for eg: [3,1,2,4] lets take 2 as an current element, in left `next smaller element` is `1` difference in index is `2-1` and in right side no `next smaller element` so take the index `4` so difference is `4-2`, hence `left[i]=1 and right[i]=2` and number of subarray where 2 is considered to be minimum is `left[i]*right[i]=1*2`

### Base case

- so we have to handle the base case when there is duplicate elements
- `eg:[1,3,1]`, [1], [3], [1] ,[1,3], [3,1], [1,3,1] -> 1+3+1+1+1+1 = `8`
- for element `1` range is `[1,3,1]`, so number of subarrays is `(0-0+1)*(2-0+1)` = 3
- for element `3` range is `[3]`, so number of subarrays is `(1-1+1)*(1-1+1)` = 1
- for element `1` range is `[1,3,1]`, so number of subarrays is `(2-0+1)*(2-2+1)` = 3
- then result is `1*3 + 3*1 + 1*3` = `9` but answer is `8`
- so how we prevent this problem, so for element at index 0 which is `1` we need to build the range to be `[1,3]` so now the number of subarray is `(0-0+1)*(1-0+1)` = `2`
- then result is `1*2 + 3*1 + 1*3` = `8`, so how we prevent the range ? its easy while calculating next smaller element from `right side consider stack to be strictly increasing` and from `left side not consider the stack to be strictly increasing` .just check the code i have commented the part.so monotonic stack in one case is strictly increasing and in other case not strictly increasing.so this is how we prevent the duplicate addition



<Tabs>
<TabItem value="java" label="Java">

```js
// reverse means we will start filling the next_smaller_element from back
    public int[] next_smaller_element(int[] arr,boolean reverse){
        int n = arr.length;
        int[] res = new int[n];
        Stack<Integer> stack = new Stack<>();// stack for evaluating next smaller element conatins index
        if(reverse){
            // next samller element from back for evaluating right[]
            for(int i=n-1;i>=0;i--){
                // while loop to maintain the monotonic stack where top should be bigger - strictly increasing
                // note inside stack we put index
                while(!stack.isEmpty() && arr[stack.peek()] >= arr[i]){
                    stack.pop();
                }
                res[i] = stack.isEmpty() ? n: stack.peek();//put index of next smaller element
                res[i] = res[i]-i;//now we need the count[number of element between current element and next smaller element] so next_smaller_element_index - current index
                stack.push(i);
            }
        }else{
            // next samller element from from for evaluating left[]
            for(int i=0;i < n;i++){
                // while loop to maintain the monotonic stack where top should be bigger - not strictly increasing
                // not strictly increasing to cover the base case: [1,5,1] where array elements are not unique
                while(!stack.isEmpty() && arr[stack.peek()] > arr[i]){
                    stack.pop();
                }
                res[i] = stack.isEmpty() ? -1 : stack.peek();
                res[i] = i-res[i];
                stack.push(i);
            }
        }
        return res;
    }
    public int sumSubarrayMins(int[] arr) {
        int mod = (int)Math.pow(10,9)+7;// mod value for handling the int overflow
        // now get the next smaller element from left and right side
        int[] left = next_smaller_element(arr,false);// reverse is false
        int[] right = next_smaller_element(arr,true);// reverse is true
        long sum = 0;
        for(int i=0;i<arr.length;i++){
            // sum=+arr[i]*left[i]*right[i], where left[i]*right[i] is the number of subarray formed where arr[i] is minimum
            sum = (sum + (long)arr[i]*left[i]*right[i])%mod;
        }
        return (int)sum;
    }

```

</TabItem>

<TabItem value="other" label="Other">

```
currently no other languages supported
```

</TabItem>

</Tabs>

#### time complexity: `O(N)`