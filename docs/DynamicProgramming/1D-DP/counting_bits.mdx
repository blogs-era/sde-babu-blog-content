```js
class Solution {
    /*
    lets develop the pattern

    n=0 - 0000
    
    n=1 - 0001 (1+dp[n-1])
    
    n=2 - 0010 (1+dp[n-2])
    n=3 - 0011
    
    n=4 - 01 00 (1+dp[n-4]) (we can see 1 is present in all the element at msb and rest is same as the previous group)   
    n=5 - 01 01 (1+dp[n-4]) 1 is for msb and rest we have "01" which also present when "n=1"
    n=6 - 01 10
    n=7 - 01 11

    n=8 - 1000 (1+dp[n-8])
    n=9 - 1001 (1+dp[n-8])

    hence we se a pattern: 1 + dp[n-offset]
    offsets are: [1,2,4,8,16...]
    */
    public int[] countBits(int n) {
        int[] dp = new int[n+1];
        // base case
        if(n==0)return dp;
        int offset = 1;
        for(int i=1;i<=n;i++){
            // check if there is need to update the offset
            if(offset*2 == i)offset = offset*2;
            dp[i] = 1+dp[i-offset];
        }
        return dp;
    }
}

```