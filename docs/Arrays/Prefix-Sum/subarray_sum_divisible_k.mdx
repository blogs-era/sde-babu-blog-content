```js

class Solution {
    /*
    remainder[i] = prefix_sum%k
    arr:        [  4,5,0,-2,-3,1]
    prefix_sum: [0,4,9,9,7,4,5]
    remainder:  [0,4,4,4,2,4,0]
    freq:       [1,1,2,3,1,4,2]
    hence count = 1(reapeat of 4) + 2(reapeat of 4) + 3(reapeat of 4) + 1(reapeat of 0) => 7 


    edge_case: [-1,2,9],k=2 because in this prefix_sum at one instant is negative hence remainder will become incorrect
    now remainder should be positive but how -1%2 is negative
    now -1%2 means 2*n-1 (add 2 and -2) so 2*n-1 + 2 -2 = 2*(n-1) + 1 = 2N + 1 => 1%2 = remainder = 1
    formula: -x % k => (-x%k) + k
    arr:        [ -1,2,9]
    prefix_sum: [0,-1,1,10]
    remainder:  [0,1,1,0]
    freq:       [1,1,2,2]
    output = 1 + 1 => 2
    */
    public int subarraysDivByK(int[] nums, int k) {
        int prefix_sum = 0,count = 0;
        HashMap<Integer,Integer> count_map = new HashMap<>();
        count_map.put(0,1);
        for(int i=0;i<nums.length;i++){
            prefix_sum+=nums[i];// update the prefix sum
            int remainder = prefix_sum%k;
            if(remainder < 0)remainder+=k;
            if(count_map.containsKey(remainder))count+=count_map.get(remainder);
            count_map.put(remainder,count_map.getOrDefault(remainder,0)+1);
        } 
        return count;
    }
}
```