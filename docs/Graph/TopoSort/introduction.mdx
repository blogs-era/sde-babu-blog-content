```js
class Solution
{
    static int[] topoSort(int V, ArrayList<ArrayList<Integer>> adj) 
    {
        // note graph should be DAG otherwise topo sort not possible
        // in input graph can be cyclic 
        int[] order = new int[V];// vertices in topological order
        // first calculate indegree of all the nodes
        int[] indegree = new int[V];
        for(ArrayList<Integer> neighbours: adj){
            for(Integer neighbour: neighbours){
                indegree[neighbour]++;
            }
        }
        Queue<Integer> q = new LinkedList<>();
        // add all the element with 0 indegree in the queue
        for(int i=0;i<indegree.length;i++){
            if(indegree[i]==0)q.add(i);// add the element with 0 indegree
        }
        int index = 0;
        // loop through the queue
        while(!q.isEmpty()){
            int node = q.poll();// poll the node and add it into the result
            order[index++] = node;
            // reduce the indegree of all the neighbours             
            for(Integer neighbour: adj.get(node)){
                if(indegree[neighbour] > 0){
                    indegree[neighbour]--;
                    if(indegree[neighbour]==0)q.add(neighbour);
                }
            }
        }
        if(index==0)return new int[]{};// so if the input graph has cycle means there is no element with indegree 0 initially
        return order;
    }
}

```