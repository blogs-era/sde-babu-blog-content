---
sidebar_position: 2
title: Network Delay Time
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

export const Highlight = ({children, color,txt}) => (
  <span
    style={{
      backgroundColor: color,
      borderRadius: '2px',
      color: '#fff',
      padding: '0.2rem',
    }}>
    {children}
  </span>
);

Level - <Highlight color="#fece2f">Medium</Highlight>

### Statement

> You are given a network of n nodes, labeled from 1 to n. You are also given times, a list of travel times as directed edges `times[i] = (ui, vi, wi)`, where `ui` is the source node, `vi` is the target node, and `wi` is the time it takes for a signal to travel from source to target.

We will send a signal from a given node `k`. Return the `maximum time` it takes for all the `n` nodes to receive the signal. If it is impossible for all the n nodes to receive the signal, return `-1`

### You can try it at

- https://leetcode.com/problems/network-delay-time/

### Example

![example](https://assets.leetcode.com/uploads/2019/05/23/931_example_1.png)

```
Input: times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2
Output: 2

```

### Approach

- please before going to solution section it is utmost important to implement [dijkstra algo](./introduction.mdx), because it is almost same.
- just we need to change the `create graph function` because in this we need directed graph
- after getting shortest time from source node to all the other nodes,  extract the maximum time we get.
- if any shortest time is infinite means source node can't able to reach at target node hence return `-1`.  



<Tabs>
<TabItem value="java" label="Java">

```js
class Solution {
     // main function
    public int[] dijkstra(int V, ArrayList<ArrayList<ArrayList<Integer>>> adj, int S)
    {
        int[] dis = new int[V];// distance array
        // distance from a node from source to all other node is infinite for now and distance from S to S is 0
        for(int i=0;i<V;i++){
            if(S!=i)dis[i] = Integer.MAX_VALUE;
        }
        // Priority Queue to select the shortest distance first, min-heap-priority-queue
        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->a[1]-b[1]);// consist of [node,dis]
        pq.add(new int[]{S,0});// add source node to S and dis to be 0 
        while(!pq.isEmpty()){
            int[] element = pq.poll();// poll the node
            int node = element[0],wt = element[1];
            // get all the neighbour of node
            ArrayList<ArrayList<Integer>> neighbours = adj.get(node);
            for (ArrayList<Integer> neigh : neighbours) {
                int neigh_node = neigh.get(0),dis_from_node = neigh.get(1);
                if(wt+dis_from_node < dis[neigh_node]){
                    dis[neigh_node] = wt+dis_from_node;// update the distance of neigh node
                    pq.add(new int[]{neigh_node,dis[neigh_node]});
                }
            }
        }
        return dis;
    }
    public ArrayList<ArrayList<ArrayList<Integer>>> createDirectedGraph(int V,int E,int[][] edges){
        ArrayList<ArrayList<ArrayList<Integer>>> adj = new ArrayList<>();
        // there are V nodes
        for(int i=0;i<V;i++){
            adj.add(new ArrayList<>());
        }
        // iterate through all the edges
        for(int i=0;i<E;i++){
            int[] edge = edges[i];
            int u = edge[0],v = edge[1],w = edge[2];
            adj.get(u).add(new ArrayList<>(Arrays.asList(v,w)));// connect u to v with weight w
        }
        return adj;
    }
    public int networkDelayTime(int[][] times, int n, int k) {
        int E = times.length;
        n = n+1;// take n as n+1 because it is 1 based indexing
        ArrayList<ArrayList<ArrayList<Integer>>> adj = createDirectedGraph(n,E,times);  
        int[] res = dijkstra(n, adj, k);
        int maxi = Integer.MIN_VALUE;
        for(int i=1;i<n;i++){
            // System.out.println(res[i]);
            if(res[i]==Integer.MAX_VALUE)return -1;// means we can't reach this node from source node
            maxi = Math.max(res[i],maxi);
        }
        return maxi;
    }
}

```

</TabItem>

<TabItem value="other" label="Other">

```
currently no other languages supported
```

</TabItem>

</Tabs>


### Time Complexity

> `O(nlog(n) + E)`